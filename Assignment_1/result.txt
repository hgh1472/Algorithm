정렬된 데이터가 들어오는 경우
n = 10000
insertion : 0.03ms
selection : 107.312ms
차이가 나는 이유 : 선택정렬은 정렬여부와 상관없이 모든 반복문이 실행되지만, 삽입정렬은 정렬되어있을 경우
내부 반복문이 반복되지 않는다.
선택정렬은 첫 번쨰 for문 반복문의 i 인자까지 배열을 훑으면서, 최댓값을 찾는다.
따라서 정렬된 데이터가 들어와도 O(n^2)의 시간복잡도가 소요된다.
하지만 삽입정렬에서 내부 반복문은 ar[j]과 arr[j - 1]인덱스 값을 비교해서
arr[j - 1]값이 더 클때만 반복문이 수행되므로 정렬된 데이터가 들어올 경우
O(n)의 시간복잡도가 소요된다.
증가율 : 삽입정렬은 O(n)만큼 시간이 증가하고, 선택정렬은 O(n^2)
만큼의 시간이 걸린다.

역순으로 정렬된 데이터가 들어오는 경우
n = 10000;
insertion : 197ms
selection : 99ms
차이가 나는 이유 : 삽입정렬은 매 순간마다 SWAP을 하지만, 선택정령은 반복당 1회만 수행한다.
즉, 반복문이 반복되는 횟수는 거의 같지만, 연산에서의 차이가 있어서
소요되는 시간 차이가 발생한다.
증가율 : 두 정렬 모두 O(n^2)에 따라서 시간이 증가한다.

정렬이 안된 데이터가 들어오는 경우
n = 10000;
insertion : 107ms
selection : 96ms
증가율 : 두 정렬 모두 O(n^2)에 따라서 시간이 증가한다.